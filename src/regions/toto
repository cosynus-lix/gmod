type value = B.t
val ( < ) : B.t -> B.t -> bool
val ( > ) : B.t -> B.t -> bool
val ( <= ) : B.t -> B.t -> bool
val ( >= ) : B.t -> B.t -> bool
exception Undefined
val zero : B.t
type bound = Opn of B.t | Iso of B.t | Cls of B.t | Pun of B.t
val rvb : bound -> B.t
val reverse_bound : bound -> bound
val close_bound : bound -> bound
val open_bound : bound -> bound
val bob : bound -> bool
val alter_parity : bound -> bool
type t = bound list
val action : (B.t -> B.t) -> bound list -> bound list
val string_of : bound list -> string
val unbounded_connected_component_must_be_added :
  bound list -> bound list -> bool
val value_of_last_bound : bound list -> B.t
val value_of_the_first_bound : bound list -> B.t
val is_valid : bound list -> bool
val is_empty : 'a list -> bool
val is_not_empty : 'a list -> bool
val is_full : bound list -> bool
val is_not_full : bound list -> bool
val contains_zero : bound list -> bool
val does_not_contain_zero : bound list -> bool
val contains_more_than_zero : bound list -> bool
val contains_at_most_zero : bound list -> bool
val lacks_at_most_zero : bound list -> bool
val lacks_more_than_zero : bound list -> bool
val parity : bool -> bound list -> bool
val belongs_to : B.t -> bound list -> bool
val empty : 'a list
val full : bound list
val iso : B.t -> bound
val pun : B.t -> bound
val cls : B.t -> bound
val opn : B.t -> bound
val make : bound list -> bound list
val atom : B.t -> bound list
val discrete : ?do_sort:bool -> B.t list -> bound list
val coatom : B.t -> bound list
val codiscrete : ?do_sort:bool -> B.t list -> bound list
val interval : bool -> bool -> B.t -> B.t -> bound list
val initial : bool -> B.t -> bound list
val final : bool -> B.t -> bound list
val cointerval : bool -> bool -> B.t -> B.t -> bound list
val monotonic_map : (B.t -> B.t) -> bound list -> bound list
val normalize : bound list -> bound list
val complement : bound list -> bound list
val binary_boolean_operator :
  (bool -> bool -> bool) -> bound list -> bound list -> bound list
val symmetric_difference : bound list -> bound list -> bound list
val intersection : bound list -> bound list -> bound list
val union : bound list -> bound list -> bound list
val difference : bound list -> bound list -> bound list
val exists : (bool -> bool -> bool) -> bound list -> bound list -> bool
val for_all :
  (bool -> bool -> bool) -> bound list -> bound list -> bool
val is_included : bound list -> bound list -> bool
val is_not_included : bound list -> bound list -> bool
val compare : bound list -> bound list -> int
val add_zero : bound list -> bound list
val remove_zero : bound list -> bound list
val first_connected_component :
  ?flag:bool ref -> bound list -> bound list
val last_connected_component : ?parity:bool -> bound list -> bound list
val end_bound : ?lb:bound -> bound list -> bound
val end_bound_below : B.t -> bound list -> bound
val future_extension :
  ?flag:bool ref -> bound list -> bound list -> bound list
val unbounded_component : bound ref
val kept : bound option ref
val clear : unit -> unit
val load : bound -> unit
val unload : unit -> bound
val clear_all : unit -> unit
val past_extension :
  ?circle_mode:bool -> bound list -> bound list -> bound list
val future_closure :
  ?circle_mode:bool -> bound list -> bound list * bool
val past_closure : bound list -> bound list * bool
module type DirectedTopology =
  sig
    val interior : t -> t -> t
    val closure : t -> t -> t
    val future_extension : t -> t -> t
    val past_extension : t -> t -> t
  end
module HalfLine :
  sig
    val is_bounded : bound list -> bool
    val is_not_bounded : bound list -> bool
    val closure_contains_zero : bound list -> bool
    val interior_contains_zero : bound list -> bool
    val interior_does_not_contain_zero : bound list -> bool
    val glb : bound list -> B.t
    val lub : bound list -> B.t
    val interior : bound list -> bound list
    val closure :
      ?unbounded_answer:bool ref -> bound list -> bound list
    val boundary : bound list -> bound list
    val string_of :
      ?empty_set_denotation:string ->
      ?infinity_denotation:string ->
      ?open_infinity:bool -> bound list -> string
    val future_extension :
      ?flag:bool ref -> bound list -> bound list -> bound list
    val future_closure : bound list -> bound list * bool
    val past_extension : bound list -> bound list -> bound list
  end
module Circle :
  sig
    val closure_contains_zero : bound list -> bool
    val boundary_contains_zero : bound list -> bool
    val boundary_does_not_contain_zero : bound list -> bool
    val interior_contains_zero : bound list -> bool
    val interior_does_not_contain_zero : bound list -> bool
    val string_of :
      ?empty_set_denotation:string ->
      ?full_set_denotation:string -> bound list -> string
    val interior : bound list -> bound list
    val closure : bound list -> bound list
    val boundary : bound list -> bound list
    val future_extension :
      ?flag:bool ref -> bound list -> bound list -> bound list
    val future_closure : bound list -> bound list * bool
    val past_extension : bound list -> bound list -> bound list
  end
