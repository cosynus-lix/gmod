module type S =
sig

 (** Graded boolean algebra of areas. Each area has a rank, that is
      to say a natural number which is to be thought of as its "geometric dimension". Given two areas x and y of 
      rank d and e the rank of the product x*y is d+e. The collection of areas of rank d forms a boolean algebra 
      A_n. The boolean algebra of areas of null rank, that is to say A_0, is isomorphic to {true,false}. The areas 
      of rank 1 generate the graded boolean algebra in the sense that any element of A_n is a finite join of n-fold
      products i_1*...*i_n where the rank of each i_k is 1. Such products are called bricks.

      The graded boolean algebras is generated by the areas of rank 1 the way that monomials generate the graded 
      algebra of polynomials.

      The standard example is provided by the finite union of hypercubes where * is the Cartesian product, the 
      elements of rank 1 are the intervals of the real line.

      A graded boolean algebra might not be freely generated, indeed in the preceding example one has 
      [0,2]U[2,3]=[0,1]U[1,3]. Therefore, since the areas are implemented as finite sets of bricks, we need a 
      normal form to decide whether two values represent the same area. The normal form is actually obtained by 
      calling the complement function two times which returns the collection of maximal sub-bricks. The theoretic 
      explanation of this approach is the Galois connection between finite sets of bricks and areas.

      Practically, the product, meet and complement operators preserve the normal forms but the join one does not. *)

  type underlying
  
  type regular_value
    (** Range of values for the bounds of intervals. *)
  
  type generator
  (** Intervalles "géométriques". *) 
  
  type point
  (** Points de l'espace "géométrique". *)
  
  type brick
  (** Cubes au sens "géométrique", c'est-à-dire produit
      d'intervalles. *)
  
  type ints
  
  type t
  (** Région cubique, le type que l'on implémente. *)
  
  exception Undefined
  (** Some functions provided by the module Area are partially
  defined. The exception Undefined is thus raised when the
  argument does not belong to the domain of definition. *)
  
  val add: brick -> t -> t
  
  val remove: brick -> t -> t
  
  (** La région réduite au point p, c'est-à-dire \{\{p.(1)\}x...x\{p.(n)\}\}. *)
  val atom: ?u:underlying -> point -> t 
  val base: t -> t
  
  (** Teste l'appartenance d'un point à une région cubique. *)
  val belongs_to: point -> t -> bool 
  
  (** Teste l'appartenance d'un point à la clôture topologique de la
      région cubique donnée. *)
  val belongs_to_closure: point -> t -> bool 
  
  val boundary: t -> t
    (** Topological boundary. *)
    
  val bounded: bool -> bool -> regular_value -> regular_value -> t 
    (** \[a,b\], \]a,b\[, \[a,b\[ ou \]a,b\] e.g. [bounded true false
  2 3] returns the interval \[2,3\[. *)
  
  val cardinal: t -> int
    (** The number of cubes of the covering. Provided by the functor Set.Make. *)
  
  val choose: t -> brick
    (** Returns a subcube of the area. If the argument is a normal form, the returned subcube is a maximal subcube 
    of the argument.*)
  
  val cofinal: t -> t -> bool
    (** [cofinal a1 a2] returns [true] if and only if any point of
  [a1] and [a2] can be reached from a point of [meet a1 a2]
  following an anti-directed path. *)
  
  val coinitial: t -> t -> bool
    (** [coinitial a1 a2] returns [true] if and only if any point of
  [a1] and [a2] can be reached from a point of [meet a1 a2]
  following a directed path. *)
  
  val common: t -> t 
    (** The common part, that is to say the intersection of all the
  bricks of the argument. It might not be a brick and two
  argument having the same normal form might have different
  common part. *)
  
  val compare: t -> t -> int              
    (** Matches the specification required by the parameter of the
  functor Set.Make. *)
  
  val complement: t -> t 
    (** Return the normal form of the complement of the argument even
  if the argument is not a normal form. *)
  
  val complement_of_cube: brick -> t
    (** Return the normal form of the complement of a brick. *)
  
  val compress: t -> t 
    (** Remove any brick that is contained in another brick of the
  argument.*)
  
  val connected: t -> bool 
    (** Tests whether the argument is connected. *)
  
  val connected_component: brick -> t -> t 
    (** Return the connected component which contains a given brick. *)
  
  val closure: t -> t 
    (** Topological closure: the least closed subset containing the
  argument.*)
  
  val deadlock_attractor: t -> t
    (** Locus of points of the argument from which one cannot avoid to
  reach a deadlock. *)
  
  val deadlocks: t -> t
    (** Collection of deadlocks of the argument, seen as a discrete
  area. It may not be contained in the argument but always in
  its topological closure. *)
    
  val difference: t -> t -> t 
    (** The set theoretic difference, (difference a b) returns the locus
  of points contained in a, not in b.*)
  
  val dimension: t -> int
    (** Rank of the argument in the graded Boolean algebra. *)
  
  val downward: t -> t 
    (** Cône en-dessous d'une région. *)
  
  val empty: ?u:underlying -> ?d:int -> unit -> t 
    (** Région vide de dimension n. *)
  
  val exists: (brick -> bool) -> t -> bool
  
  val exponent: t -> int -> t
  
  val face: bool -> int -> t -> t
  
  val factorize: ?unpacked:bool -> t -> (bool array) list
  
  val filter: (brick -> bool) -> t -> t
  val full: ?u:underlying -> ?d:int -> unit -> t   
  val fold: (brick -> 'a -> 'a) -> t -> 'a -> 'a
  
  val future_cone: t -> t -> t 
    (** Locus of points of the second argument that can be reached by
  a directed path starting from the first argument. The first
  argument must be contained in the seconde one.  *)
  
  val future_cone_point: point -> t -> t 
    (** Same as future_cone except the first argument is reduced to a
  point. *)
  
  val generalized_common: ?d:int -> t -> t 
  
  val generalized_product: int -> (t array) -> t (* Voir détails dans la documentation. *)
  
  val ginzu: t -> t
    (** Partition of the argument into bricks whose faces lie in an
  hyperplane that carries some face of some brick of the
  argument. The result is "optimal" when the normal form of the
  argument is provided. *)
  
  val glb: t -> point
    (** Greatest lower bound, when it exists, with respect to the
  product order. Otherwise an exception is raised.*)
  
  val infinity_attractor: t -> t
    (** Locus of points from which deadlocks cannot be reached. *)
  
  val initial: bool -> regular_value -> t
    (** Either \[0,x\] or \[0,x\[ depending on the value true or false of
  the boolean. *)
  val interior: t -> t
    (** Topological interior : the greatest open subset contained in the
  argument. The normal form of the argument must be given. *)
  val is_empty: t -> bool
  val is_not_empty: t -> bool
  val is_full: t -> bool
  val is_not_full: t -> bool
    (** Test wether an area is emty or not. *)
  val is_included: t -> t -> bool
    (** Test wether the first argument is a subset of the second
  one. The normal form of the second argument must be given. *)
  val in_touch: t -> t -> bool
    (** Test wether the topological closure of any of the arguments
  meets the other one. From a mathematical point of view, it is
  equivalent to the existence of a path between the two
  areas. *)
  val iter: (brick -> unit) -> t -> unit
    (** From the functor Set. *)
  val join: t -> t -> t 
    (** Set theoretic union. Does not preserve the normal forms. *)
  val join_list: t list -> t
  val join_array: t array -> t
  val levelwise_product: ?u:underlying -> ?g:int array -> int (*?level:int*) -> (t array array) -> t 
    (** Even more general then the generalized product *)
  val locus_higher_than: ?filtration:bool -> ?g:int array -> int -> (t array array) -> t
  val locus_lower_than: ?chain:bool -> ?g:int array -> int -> (t array array) -> t
  val lub: t -> point 
    (** Greatest lower bound, when it exists, with respect to the
  product order. Otherwise an exception is raised.*)
  val make: brick list -> t 
    (** The area obtained as the union of the bricks (seen as areas) of
  the list. *)
  val meet: t -> t -> t 
    (** Set theoretic intersection. Preserve the normal forms. *)
  val meet_list: t list -> t
  val meet_array: t array -> t
  val mem: brick -> t -> bool
    (** From the functor Set. *)
  val might_go_deadlock: t -> t 
    (** Locus of points of the argument from which there exists a
  directed path which leads to a deadlock. *)
  val might_go_infinity: t -> t 
    (** Locus of points of the argument from which there exists a
  directed path which leads to the infinite. *)
  val min_elt: t -> brick
    (** From the functor Set. *)
  
  (*
    val local_maxima: t -> t (* Renvoie la région de dimension 0 constituée des bornes supérieures locales. *)
    val local_minima: t -> t (* Renvoie la région de dimension 0 constituée des bornes inférieures locales. *)
  *)
  
  val local_might_go_infinity: ints (*Common.Soi.t*) -> t -> t
  val local_deadlock_attractor: ints (*Common.Soi.t*) -> t -> t
  val next: brick -> t -> brick
    (** Next brick according to the total order used by the functor
  Set. *)
  val normalize: t -> t 
    (** Normal form of an area. *)
  val minimize: t -> t 
    (** Normal form of an area. *)
  val of_cube: brick -> t
    (** The area whose unique maximal brick is given as the argument.*)
  val of_array: brick array -> t
  val of_list: brick list -> t
  val past_cone: t -> t -> t 
    (** Locus of points of the second argument that can be reached by an
  anti-directed path starting from the first argument. The first
  argument must be contained in the seconde one.  *)
  val past_cone_point: point -> t -> t 
    (** Same as past_cone except the first argument is reduced to a
  point. *)
  val print: t -> unit 
    (** Pretty printing. *)
  val product: t -> t -> t
    (** Cartesian product. *)
  val product_list: t list -> t
  val product_array: t array -> t
  val product_fun: (int -> t) -> int -> int -> t
  val reachable: t -> t  
    (** Locus of points of the argument that can be reached from the
  origin. If the origin does not belong to the topological
  closure of the argument, the empty area is returned. *)
  
  (* val reachable_from: t -> t -> t  Sous-région des points accessibles par un chemin dirigé depuis une région donnée. *) 
  (* val reachable_from_point: point -> t -> t  Sous-région des points accessibles par un chemin dirigé depuis un point donné. *) 
  
  val remove_useless_empty_brick: t -> t
    (** If the argument is not empty, then the empty brick is removed
  from the covering. *)
  val sources: t -> t
  val string_of: ?gui:bool -> t -> string 
    (** Turn a cubical area into a printable string. *)
    (*  val slash: int -> regular_value -> t -> t *) (* not implemented yet *)
  val terminal: bool -> regular_value -> t (* [x,~[ ou ]x,-[ selon la valeur true/false du booléen. *)
  val to_array: t -> brick array
  val to_list: t -> brick list
  val upper_corners_area: t -> t (* Renvoie les coins supérieurs des régions cubiques. *)
    (** Cône au-dessous d'une région. *)
  val upward: t -> t 
  val underlying: t -> underlying
  val cset2D_of_complement_of_area: t -> ( t * t * t )
end
