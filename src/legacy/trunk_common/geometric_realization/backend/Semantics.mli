module type Parameters = sig
  val program:AbstractSyntax.t
  val reduce_cfg:bool
  val verbosity:int
end (*Parameters*)

module type S = sig

  val control_flow_graph: string -> (PV2CFG.D.Skeleton.t * PV2CFG.D.Skeleton.vertex list)
  (**[control_flow_graph procname] returns the control flow graph of the process identified by [procname]*)

  val busy_section: (resource:(AbstractSyntax.Resource.t) -> procname:string -> PV2CFG.value_for_busy_section)
  (**[busy_section ~resource ~procname] returns the busy section of [resource] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_mutex: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_mutex mtx procname] returns the busy section of the mutex identified by [mtx] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_semaphore: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_semaphore sem procname] returns the busy section of the semaphore identified by [sem] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_synchronization: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_synchronization sync procname] returns the busy section of the synchronization [syn] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_channel: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_channel chnl procname] returns the busy section of the channel [chn] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_monitor: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_monitor mntr procname] returns the busy section of the monitor [mntr] on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_notify: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_notify ntf procname] returns the section of points where the notification [ntf] is raised on the control flow graph of process identified
  by [procname]*)

  val busy_section_of_write: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_write var procname] returns the busy section of the write/write colliding access to variable [var] on
  the control flow graph of process identified by [procname]*)

  val busy_section_of_read: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_read var procname] returns the busy section of the read/write colliding access to variable [var] on the
  control flow graph of process identified by [procname]*)

  val busy_section_of_variable: string -> string -> PV2CFG.value_for_busy_section
  (**[busy_section_of_variable var procname] returns the busy section of the colliding access to variable [var] on the control flow graph of process identified
  by [procname]*)

  val empty_area: PV2CFG.C.Area.t
  (**The empty subset of the underlying state space*)

  val forbidden_area_of_the_resource: AbstractSyntax.Resource.t -> PV2CFG.C.Area.t
  (**[forbidden_area_from_resources r] returns the forbidden area generated by the resource [r]*)

  val forbidden_area_from_mutex: unit -> PV2CFG.C.Area.t
  (**[forbidden_area_from_mutex ()] returns the forbidden area generated by all the mutex of the program*)

  val forbidden_area_from_semaphores: unit -> PV2CFG.C.Area.t
  (**[forbidden_area_from_semaphores ()] returns the forbidden area generated by all the semaphores of the program*)

  val forbidden_area_from_synchronizations: unit -> PV2CFG.C.Area.t
  (**[forbidden_area_from_synchronizations ()] returns the forbidden area generated by all the synchronizations of the program*)

  val forbidden_area_from_monitors: unit -> PV2CFG.C.Area.t
  (**[forbidden_area_from_monitors ()] returns the forbidden area generated by all the monitors of the program*)

  val forbidden_area_from_channels: unit -> PV2CFG.C.Area.t
  (**[forbidden_area_from_channels ()] returns the forbidden area generated by all the channels of the program*)

  val read_critical_area: unit -> PV2CFG.C.Area.t
  (**[read_critical_area ()] returns the critical area generated by the collisions involving a reading attempt and a writing one*)

  val write_critical_area: unit -> PV2CFG.C.Area.t
  (**[write_critical_area ()] returns the critical area generated by all the collisions involving two writing attempts*)

  val critical_area: unit -> PV2CFG.C.Area.t
  (**[write_critical_area ()] returns the critical area generated by all the collisions involving two writing attempts*)

  val forbidden_area: unit -> PV2CFG.C.Area.t
  (**[forbidden_area ()] returns the forbidden area of the program*)

  val swept_forbidden_area: unit -> PV2CFG.C.Area.t
  (**[swept_forbidden_area ()] returns the forbidden area of the program in swept form*)

  val normalized_forbidden_area: unit -> PV2CFG.C.Area.t
  (**[normalized_forbidden_area ()] returns the forbidden area of the program in normal form*)

  val states_space: unit -> PV2CFG.C.Area.t
  (**[states_space ()] returns the state space of the program*)

  val factorization: unit -> bool array list
  (**[factorization ()] returns the factorization of the states space of the  program*)

  val fast_factorization: unit -> bool array list
  (**[fast_factorization ()] returns the factorization of the states space of the  program*)

  val unsafe_fast_factorization: unit -> bool array list
  (**[unsafe_fast_factorization ()] returns the factorization of the states space of the  program*)

  val safe_fast_factorization: unit -> bool array list
  (**[safe_fast_factorization ()] returns the factorization of the states space of the  program*)

  val weak_factorization: unit -> bool array list
  (**[weak_factorization ()] returns a weak factorization i.e. a bigger forbidden area is considered so that its complement (a subspace of the states space) factorizes.*)

end (*S*)

(**The results of the heaviest computations are stored so they are not performed twice*)

module Make (AS:Parameters): S
