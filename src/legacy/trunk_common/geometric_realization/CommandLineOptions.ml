module F =  Command.Flag
module SF = Command.SetFlag
(*
module CA = Command.Action
*)

let hl = Message.hl

let expand_the_option (keys,spec,doc) =
	let flag = ref true in
	let colored_keys = List.map hl keys in
	let prologue = String.concat "/" colored_keys in
	let f k =
		let () = flag := false in
		(k,spec,if !flag then Printf.sprintf "%s%s" prologue doc else "") in
	List.map f keys

let expand_all_options list_of_options =
	List.concat (List.map expand_the_option list_of_options)

let run_tests s = match s with
  | "oda" -> Test.run_tests Command.Oda
  | "dgrog" | "dgr" -> Test.run_tests Command.Dgrog
  | "cpodgrog" | "cpr" -> Test.run_tests Command.Cpodgrog
  | _ -> Printf.printf "%s the option %s is not available\n" Message.error (Common.Terminal.(color Red ("-test "^s)))

let separator = "/"

let highlight_opt = Message.hl

let all_doc more = Printf.sprintf
  "if %s, %s or even just %s occurs in the list, then all the other names
             are ignored and implicitly replaced by all \"relevant\" names. %s"
  (hl "-all") (hl "-a") (hl "-") more

let busy_section kind = Printf.sprintf
  "\n  and the busy sections from all the %s declared in the program are displayed" (hl kind)

let critical_section = Printf.sprintf
  "\n  and the critical sections from all the %s occuring in the program are displayed" (hl "variables")

let forbidden_area kind = Printf.sprintf
  "\n  and the forbidden area generated by all the %s declared in the program is displayed" (hl kind)

let comma_doc = "The elements of the list should be separated by a comma ',' without blank."

let on_off_doc = Printf.sprintf "%s/%s" (hl "on") (hl "off")

let test_doc = Printf.sprintf " One of the arguments %s, %s/%s or %s/%s must be provided"
  (hl "oda") (hl "dgr") (hl "dgrog") (hl "cpr") (hl "cpodgrog")

let usage_msg = Printf.sprintf
"Testing the library dealing with isothetic regions.
You should provide a file. Allowed extensions are .oda, .dgr, and .cpr.
In the sequel we made the following convention:
<ident list> is a list of identifiers separated by a comma ',' without blank,
             %s
<int> is an integer" (all_doc "")

let separate = Str.split (Str.regexp ",")

let list_of_options =
  [
    ["--only"],Arg.String (fun s -> Command.specified_keys := Some (separate s))," Specify the list of variable you want to know the value of. 
                                         Works for .oda, .dgr and .cpr files";
    ["--alphabetical";"-alpha"],Arg.Set Command.alphabetical," The results are returns in alphabetical order";
    ["--no-pretty-printing";"-npp"],Arg.Clear Command.pretty ," Display the internal representation instead of its semantics";
    ["--verbose-display";"-vd"],Arg.Set Command.verbose_display," Display the underlying set i.e. the arrows carrying empty areas are explicitly shown";
    ["--verbose-parser";"-vp"],Arg.Unit SF.set_parser_verbose," The PV parser displays activated rules";
    ["--verbose-lexer";"-vl"],Arg.Unit SF.set_lexer_verbose," The PV lexer displays recognized tokens";
    ["--verbosity";"-vrb"],Arg.Set_int F.verbosity," <int> How much internal information one wishes to see.
                                         The higher is the parameter the more verbose is the program. 
                                         Null value means silent.";
    ["--silent"],Arg.Unit SF.set_silent," Same as --verbosity 0";
    ["--parsing-mode";"-pm"],Arg.String SF.force_parsing_mode," Restrict the ability of the parser to directed geometric realisations of graphs (debug option)";
    ["--control-flow-graph";"-cfg"],Arg.Unit SF.set_cfg_display," Displays control flow graphs of selected processes";
    ["--cfg-reduction"],Arg.String (SF.switch_flag F.cfg_reduction),(Printf.sprintf " %s Enables/Disables Control Flow Graph reduction [default is on]" on_off_doc);
    ["--mutex-busy-section";"-mubs";"-µbs"],Arg.String SF.set_mutex_busy_section,Printf.sprintf "  <ident list> Displays the busy section of any 
                                         mutex of the list provided as an argument" ;
    ["--semaphore-busy-section";"-smbs"],Arg.String SF.set_semaphore_busy_section,Printf.sprintf " <ident list> Displays the busy section of any 
                                         semaphore of the list provided as an argument";
		["--synchronization-busy-section";"-sybs"],Arg.String SF.set_synchronization_busy_section,Printf.sprintf " <ident list> Displays the busy section of any 
                                         synchronization of the list provided as an argument";
    ["--read-busy-section";"-rbs"],Arg.String SF.set_read_busy_section,Printf.sprintf " <ident list> Displays the read critical sections related to every variable";
    ["--write-busy-section";"-wbs"],Arg.String SF.set_write_busy_section," <ident list> Displays the write critical sections related to every variable";
    ["--variable-access-busy-section";"-vabs"],Arg.String SF.set_access_busy_section," <ident list> Displays the critical sections related to every access to a variable";
    ["--channel-busy-section";"-cbs"],Arg.String SF.set_channel_busy_section," <ident list> Displays the critical sections related to every channel";
    ["--notify-busy-section";"-nbs"],Arg.String SF.set_notify_busy_section," <ident list> Displays the sections related to every notification";
		["--mutex-forbidden-area";"-mfa";"-µfa"],Arg.String SF.set_mutex_forbidden_area,Printf.sprintf "  <ident list> Displays the union of the forbidden areas of 
                                         mutex occurring in the list provided as an argument";
		["--semaphore-forbidden-area";"-smfa"],Arg.String SF.set_semaphore_forbidden_area,Printf.sprintf " <ident list> Displays the union of the forbidden areas of 
                                         semaphores occurring in the list provided as an argument";
    ["--forbidden-area";"-fa"],Arg.Unit SF.set_forbidden_area," Displays the forbidden area of the program.";
    ["--swept-forbidden-area";"-sfa"],Arg.Unit SF.set_swept_forbidden_area," Displays the forbidden area of the program 
                                         from which the redundant cubes have been removed.";
    ["--normalized-forbidden-area";"-nfa"],Arg.Unit SF.set_normalized_forbidden_area," Displays the normal form of the forbidden area of the program.";
    ["--states-space";"-states";"-st"],Arg.Unit SF.set_states_space," Displays the state space of the program.";
    ["--factorize";"-fac"],Arg.Unit SF.set_factorization," Factorize the state space of the program.";
    ["--fast-factorize";"-ffac"],Arg.Unit SF.set_fast_factorization," Factorize the state space of the program using Nicolas Ninin's improved algorithm.
                                         Redundant cubes area removed from the forbidden area before to process";
    ["--unsafe-fast-factorize";"-uffac"],Arg.Unit SF.set_unsafe_fast_factorization," Factorize the state space of the program using Nicolas Ninin's improved algorithm.
                                         Do not remove redundant cubes from the forbidden area. 
                                         Rather likely to return a partial factorization";
    ["--safe-fast-factorize";"-sffac"],Arg.Unit SF.set_safe_fast_factorization," Factorize the state space of the program using Nicolas Ninin's improved algorithm.
                                         The normal form of the forbidden area is determined first.";
    ["--weak-factorization";"-wfac"],Arg.Unit SF.set_weak_factorization," Find a bigger forbidden area so that the state space factorizes.";
    ["--selected-processes";"-sp"],Arg.String SF.selected_procs," Choose the processes to take into accont";
    ["--hide-empty-segments";"-hes"],Arg.Set F.hide_segments_carrying_empty_area," Hide segments carrying an empty area";
    (*["--gui"],Arg.Unit Gui.go," Graphic user interface";*)
    ["--fullscreen"],Arg.Set Parameter.Gui.fullscreen," Make the GUI window fill the screen";
    ["--utf8"],Arg.Set Parameter.Shell.utf8," Enable UTF-8 character set on terminal";
    ["--debug"],Arg.Set DGROG.display_all," Debug mode displays the runtime content of internal variables";
    ["--test"],Arg.String run_tests,test_doc;
  ]

let list_of_options = SpeclistMaker.make ~usage_msg ~separator ~highlight_opt list_of_options
