
open Globals
open Color

let header h i =
  let tsw = !Settings.terminal_width in
    (
      if i <> ""
      then
	(String.make ((tsw-(String.length h))/2) ' ')
	^(yellow ~bold:true ~underline:true h)
	^"\n"
	^(String.make ((tsw-2-(String.length i))/2) ' ')
	^(yellow ~bold:true "(")^i
	^(yellow ~bold:true ")")
      else
	(String.make ((tsw-(String.length h)-(String.length i))/2) ' ')
	^(yellow ~bold:true ~underline:true h)
    )^"\n"

let center ?l s =
  let n = match l with
    | Some k -> k
    | None -> String.length s
  in
  let tsw = !Settings.terminal_width in
  let aux = max ((tsw-n)/2) 0 in
    if s <> "" then
      ((String.make aux ' ')^s)
    else
      ""

let bb s = blue ~bold:true s

let br s = red ~bold:true s

let bc s = cyan ~bold:true s

let bm s = magenta ~bold:true s

let b s = highlight ~underline:true s

let paragraph s = match s with
  | "display" ->
    "/"^(bb "-d")^"
    Displays pieces of information about the program to analyze according to the sub-options specified by the user.
    The sub-options have to be given as a list using blanks as separator
    The list has to be given between quotation marks "^(bb "\"")^"<list of sub-options>"^(bb "\"")^"
    The following sub-options are available:
     "^(bb "forbidden")^"/"^(bb "frbd")^" forbidden area.
     "^(bb "state")^" space of states.
     "^(bb "deadlock-attractor")^"/"^(bb "dla")^" deadlock attractor i.e. the states from which one cannot avoid to reach a deadlock.
     "^(bb "deadlock-attractor-weak")^"/"^(bb "dlaw")^"/"^(bb "concur98")^" same as deadlock attractor but implementing the \"Concur 98\" algorithm.
       This algorithm requires some closedness hypothesis. In general it provides an "^(br "underapproximation")^".
     "^(bb "local-deadlock <n>")^"/"^(bb "ldla <n>")^" area of deadlock generated by any bunch of exactly "^(bb "<n>")^" processes (instead of all).
     "^(bb "deadlocks")^"/"^(bb "dl")^" set of deadlock points.
     "^(bb "reachable")^" area of states that can be reached by an execution trace.
     "^(bb "unreachable")^" area of states that cannot be reached by an execution trace.
     "^(bb "safe")^" area of states from which a path surely run infinitely.
     "^(bb "hazardous")^" area of states from which one may reach a deadlock.
     "^(bb "overflow")^" area of states wherein one observes a stack/queue overflow, hence a message loss.
     "^(bb "cubical-set")^" two dimensional cubical set obtained from the area of possible states.
     "^(bb "3D")^"/"^(bb "3d")^" representation from a generated geom file and displays it using "^(b "Geomview")^"
	  Blue -> forbidden states,
          Red  -> deadlock attractor: can be reached and lead to a deadlock,
     "^(bb "2D <n>")^"/"^(bb "2d <n>")^" representation of the atlas of the possible states of the program from generated tikz and pdf files.
       The optional parameter "^(bb "<n>")^" is a scale factor whose value is set to 100 by default.
       Sky blue    -> can be reached and does not lead to a deadlock,
       Red         -> can be reached and lead to a deadlock (deadlock attractor),
       Violet      -> can be reached and might lead to a deadlock
       Grey        -> cannot be reached
       Dark border -> states on the boundary belong to the area
        Only available when there are two running processes.
        One can optionally specify an integer which scales the picture.
     "^(bb "2D+ <n>")^"/"^(bb "2d+ <n>")^" same as 2D with the overflow area pictured using transparency.
     "^(bb "maximal-dipaths")^"/"^(bb "maximal-dihomotopy-classes")^"/"^(bb "mdc")^" dihomotopy classes of all maximal dipaths
        Actually we don't know whether it provides an "^(bb "overapproximation")^" or an "^(bb "exact")^" result.
     "^(bb "trace")^"/"^(bb "mr-trace")^"/"^(bb "MR-trace")^" dihomotopy classes of all maximal dipaths (actually an "^(bb "overapproximation (?)")^") using Martin Raussen algorithm.
       A maximal dipath is the geometric counterpart of a maximal execution trace.
     "^(bb "factor")^"/"^(bb "fac")^" gives a partition of the set of processes of the program whose blocks run independently.
     "^(bb "pvsyntax")^"/"^(bb "pv")^" describes the syntax of the PV language, which is parsed and analyzed by the tool.
     "^(bb "credits")^"/"^(bb "cred")^" The external libraries ALCOOL uses and people who develop them.
     "^(bb "extract-maximal-traces")^"/"^(bb "emt")^" list of execution traces extracted from "^(bb "dihomotopy classes ")^"
       of the state space of the program (actually an "^(bb "overapproximation")^").
     "^(bb "equations")^"/"^(bb "eqn")^"/"^(bb "eq")^"/"^(bb "e")^" equations defining the process of the program.
     "^(bb "equation-names")^"/"^(bb "enl")^" names of the equations defining the process of the program.
     "^(bb "ressources")^"/"^(bb "res")^"/"^(bb "r")^" ressources of the program.
     "^(bb "running-processes")^"/"^(bb "running")^"/"^(bb "runpro")^" processes that actually run.
     "^(bb "the-equation")^"/"^(bb "te")^" a specific equation.
     "^(bb "critical-section")^"/"^(bb "csct")^" write-write or read-write conflicts.
     "^(bb "dining-philosophers")^"/"^(bb "philosophers")^"/"^(bb "philo")^" "^(bb "<n>")^" thorough analysis of the "^(bb "<n>")^" dining philosophers problem.
       The calculations involved become drastically long for "^(bb "<n>")^" greater than 8.
       It takes about 35 seconds for 8 philosophers and 1 hour for 9 philosophers on a 2Ghz Intel Xeon 5130.
     "^(bb "Čech-complex")^"/"^(bb "Čech")^"/"^(bb "cech-complex")^"/"^(bb "cech")^" The Čech complex associated with the maximal subcubes of the geometric model of the program.     
     "^(bb "Čech-complex-for-jplex")^"/"^(bb "Čech-for-jplex")^"/"^(bb "cech-complex-for-jplex")^"/"^(bb "cech-for-jplex")^" Same as above but the ouput format is fitted to JPlex library"     
  | "mode" ->
    "One of the following sub-option has to be specified:\n"^
      (bb "    random-branching")^" branches randomly\n"^
      (bb "    semaphore-seeker-branching")^" branches where semaphore/mutex request can be found\n"^
      (bb "    depth <n>")^" the branches are explored until depth "^(bb "<n>")^"\n"^
      (bb "    explore <n>")^" Undocumented"
  | "calcubatrix" -> "Make calculations over the graded boolean algebra of cubical areas"
  | "calcutorix" -> "Make calculations over the graded boolean algebra of torical areas"
  | "Yoneda" ->
    "Give a "^(bb "partition ")^"of the state space each element of which "^(br "underapproximates ")^"a "^(bb "Yoneda component")
  | "cardYoneda" ->
    "Return an "
    ^(br "overapproximation ")^"of the "
    ^(bb "number of Yoneda components of the states space ")
    ^"of an unfolded PV program"
  | "parabounding" ->
    (bb "gatling <n>")^" unroll the processes execution up to "^(bb "<n>")^" times."
  | "verbose" ->
    "/"^(bb "-vrb")^"/"^(bb "-v")^" Provides runtime information."
  | "fullverbose" ->
    "/"^(bb "-fvrb")^"/"^(bb "-vv")^" Provides detailed runtime information."
  | "terminal screen width" ->
    "/"^(bb "-tsw")^" Choose your terminal screen width."
  | "terminal color on" ->
    "/"^(bb "-tc-on")^" Enable colors on terminal output."
  | "terminal color off" ->
    "/"^(bb "-tc-off")^" Disable colors on terminal output."

  | "utf8 on" ->
    " Enable UTF8 on terminal output."
  | "utf8 off" ->
    " Disable UTF8 on terminal output."

  | "pv syntax" ->
    "/"^(bb "-pv")^" The PV language syntax"
  | "show configuration steps" ->
    "Explicitly describe all the configuration steps performed when alcool is run"
  | "people" -> Printf.sprintf "Who have been involved in the development of the %s software." (Color.blue ~bold:true "ALCOOL")
  | "econtact" -> Printf.sprintf "/%s Email adresses you can send messages about %s." (bb "-contact") (bb "ALCOOL")
  | "adress" -> "Postmail adress."
  | "credits" -> Printf.sprintf "The external libraries used by %s." (Color.blue ~bold:true "ALCOOL")
  | "" -> (header " Available Options " "")^"\n"
  | _ -> "Undocumented"

let welcome () =
  let s = (header " ALCOOL " "Static Analysis of Concurrency by means of Directed Algebraic Topology")^"\n"^
    (
      let aux0 = "CEA LIST" in
      let aux1 = "ALCOOL" in
      let l = (String.length "The software  is developed at ")+(String.length aux0)+(String.length aux1)
      in
	center ~l
	  (
	    Printf.sprintf "The %s software is developed at %s\n\n"
	      (Color.blue ~bold:true aux1)
	      (Color.blue ~bold:true aux0)
	  )
    )
  in
    print_string s

let help () =
  let aux0 = "-help" in
  let aux1 = "--help" in
  let l = (String.length "The options  and  provide the list of options")+(String.length aux0)+(String.length aux1) in
  let s =
    center ~l
      (
	Printf.sprintf
	  "The options %s and %s provide the list of options\n"
	  (Color.blue ~bold:true "-help")
	  (Color.blue ~bold:true "--help")
      )
  in
    print_string s

let people () =
  String.concat ""
    (List.map
       (fun s -> center s)
       [
         "\n"                     ;
         "       Eric Goubault   \n" ;
         "   Emmanuel Haucourt   \n" ;
         "     Michel Hirschowitz\n" ;
         "   Sanjeevi Krishnan   \n" ;
         "  Alexandre Lang       \n" ;
         "     Samuel Mimram     \n" ;
         "\n"
       ])

let address () =
  String.concat ""
    (List.map
       (fun s -> center s)
       [
         "\n";
         " Eric Goubault, Emmanuel Haucourt or Samuel Mimram\n" ;
         "\n";
         " at\n" ;
         "\n";
         " CEA Saclay Nano-INNOV\n" ;
         " Institut Carnot CEA LIST\n" ;
         " DRT/LIST/DTSI/LMeASI\n";
         " Point Courrier ?\n" ;
         " 91191 Gif sur Yvette CEDEX\n" ;
         "\n";
       ])

let email () =
  String.concat ""
    (List.map
       (fun s -> center s)
       [
         "\n";
         " eric.goubault@cea.fr\n" ;
         " emmanuel.haucourt@cea.fr\n" ;
         " samuel.mimram@cea.fr\n" ;
       ])

let credits () =
  let blue s = (Color.blue ~bold:true s) in
  String.concat ""
    [
      "\n";
      Printf.sprintf "Alcool is powered by the programming language %s.\n" (blue "OCaml") ;
      Printf.sprintf "  %s is developped at %s.\n" (blue "OCaml") (blue "INRIA") ;
      Printf.sprintf "Arbitrary precision algebra is provided by the library %s.\n" (blue "Numerix") ;
      Printf.sprintf "  %s is developped by %s.\n" (blue "Numerix") (blue "Michel Quercia") ;
      Printf.sprintf "The graphs are provided by the library %s.\n" (blue "Ocamlgraph") ;
      Printf.sprintf "  %s is developped by %s, %s and %s.\n"
	(blue "Ocamlgraph") (blue "Sylvain Conchon") (blue "Jean-Christophe Filliâtre") (blue "Julien Signoles") ;
      Printf.sprintf "The Graphical User Interface is designed using %s and based on the libraries %s and %s\n  through the %s interfaces provided by the libraries %s and %s.\n" (blue "Glade") (blue "Gtk") (blue "OpenGL") (blue "OCaml") (blue "LablGtk") (blue "LablGL") ;
      Printf.sprintf "  %s and %s are developed by %s.\n" (blue "LablGtk") (blue "LablGL") (blue "Jacques Garrigue") ;
      Printf.sprintf "The software %s is used to visualize 3D models.\n" (blue "Geomview")
    ]


module Syntaxes =
struct
  let cylinder =
    "
The variable \"Value\" can range over any chain admitting
a least element but no greatest one and which can be
embedded into the real line. In particular it may be the
positive half-line or the set of integers.

The variable \"Name\" is an identifier made of alphanumeric
symbols the first of which not being allowed to be a digit.

Binary = ['0'-'1']*

Integer = ['0'-'9']*

Generator =
   [Value]
   ]Value,Value[  ]Value,Value]  [Value,Value[  [Value,Value]
   [Value,-[  ]Value,-[
   (Value)  )Value(
   )Value,Value(  )Value,Value)  (Value,Value(  (Value,Value)

Expression =
   Generator  C(Binary)  @(Binary)  {X}  !X
   Expression*Expression  Expression/Expression
   Expression|Expression  Expression&Expression
   Expression^Integer  in.Expression  cl.Expression

Binding =
   Name = Expression
"

  let cube =
    "
The variable \"Value\" can range over any chain admitting
a least element but no greatest one and which can be
embedded into the real line. In particular it may be the
positive half-line or the set of integers.

The variable \"Name\" is an identifier made of alphanumeric
symbols the first of which not being allowed to be a digit.

Integer = ['0'-'9']*

Generator =
   [Value]
   ]Value,Value[  ]Value,Value]  [Value,Value[  [Value,Value]
   [Value,-[  ]Value,-[

Expression =
   Generator  C(Integer)  @(Integer)  {Expression}  !Expression
   Expression*Expression  Expression/Expression
   Expression|Expression  Expression&Expression
   Expression^Integer  in.Expression  cl.Expression
"

  let torus =
    "
The variable \"Value\" can range over any chain admitting
a least element but no greatest one and which can be
embedded into the real line. In particular it may be the
positive half-line or the set of integers.

The variable \"Name\" is an identifier made of alphanumeric
symbols the first of which not being allowed to be a digit.

Integer = ['0'-'9']*

Generator =
   (Value)
   )Value,Value(  )Value,Value)  (Value,Value(  (Value,Value)
   (Value,-(  )Value,-(

Expression =
   Generator  C(Integer)  @(Integer)  {Expression}  !Expression
   Expression*Expression  Expression/Expression
   Expression|Expression  Expression&Expression
   Expression^Integer  in.Expression  cl.Expression
"

  let kwa ?(hl=green) lk = match lk with
    | k::lk -> (List.fold_left (fun accu k -> accu^"|"^(hl k)) ("("^(hl k)) lk)^")"
    | []    -> ""

  let rcl ?(s="") g a =
    ((cyan ~bold:true a)^" :=\n  ["^(blue g)^" ["^(if s<>"" then "["^(green s)^"] " else "")^(blue a)^"]]\n")

  (* Displays the syntax of the pv language. *)

  let pv () =
    let tsw = !Settings.terminal_width in
    String.concat ""
      [
	("\n"^(String.make tsw '_')^"\n\n");
	(header " Lexical conventions " "")^"\n" ;
	((cyan ~bold:true "integer")^" := ")^"\n";
	("  [ '"^(magenta ~bold:true "0")^"'-'"^(magenta ~bold:true "9")^"' ]+\n")^"\n";
	((cyan ~bold:true "filename")^" := ")^"\n";
	("  [ '"^(magenta ~bold:true "a")^"'-'"^(magenta ~bold:true "z")^"' '"^(magenta ~bold:true "A")^"'-'"^(magenta ~bold:true "Z")^"' '"^(magenta ~bold:true "0")^"'-'"^(magenta ~bold:true "9")^"' '"^(magenta ~bold:true "_")^"' '"^(magenta ~bold:true ".")^"' '"^(magenta ~bold:true "-"^"' ]+\n"))^"\n";
	((cyan ~bold:true "identifier")^" := ")^"\n";
	("  [ '"^(magenta ~bold:true "a")^"'-'"^(magenta ~bold:true "z")^"' '"^(magenta ~bold:true "A")^"'-'"^(magenta ~bold:true "Z")^"' '"^(magenta ~bold:true "_")^"' ]+([ '"^(magenta ~bold:true "a")^"'-'"^(magenta ~bold:true "z")^"' '"^(magenta ~bold:true "A")^"'-'"^(magenta ~bold:true "Z")^"' '"^(magenta ~bold:true "0")^"'-'"^(magenta ~bold:true "9")^"' '"^(magenta ~bold:true "_")^"' ]*)")^"\n";
	("\n"^(String.make tsw '_')^"\n\n");
	(header " Grammar " "")^"\n" ;
	(* ((String.make tsw '_')^"\n\n");*)
	(rcl "filename" "list_of_filenames")^"\n";
	(rcl "identifier" "list_of_identifiers")^"\n";
	(rcl ~s:"|" "identifier" "init_list")^"\n";

	(
	  (cyan ~bold:true "declaration")^" :=\n"^
	    "  "^(kwa ["#include";"#incl"])^(blue " list_of_filenames")^" |\n"^
	    "  "^(kwa ["#mutex";"#mtx"])^(blue " list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#mutex_recursive";"#mtxr"])^" "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#mutex_normal";"#mtxn"])^(blue " list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#mutex_errorcheck";"#mtxec"])^(blue " list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#semaphore";"#sem"])^" ["^(blue "integer")^"] "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#semaphore_quantitative";"#semq"])^" ["^(blue "integer")^"] "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#fifo";"#file";"#queue"])^" ["^(blue "integer")^"] "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#lifo";"#pile";"#stack"])^" ["^(blue "integer")^"] "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#synchronisation";"#synchro";"#syn"])^" ["^(blue "integer")^"] "^(blue "list_of_identifiers")^" |\n"^
	    "  "^(kwa ["#monitor";"#mntr"])^" "^(blue "list_of_identifiers")^"\n"
	)^"\n"
	;
	(rcl "declaration" "list_of_declarations")^"\n" ;
	
	(
	  (cyan ~bold:true "arithmetic")^" :=\n"^
	    "  "^(green "?")^" | "^(blue "integer")^" | "^(blue "identifier")^" | "^
	    (green "(")^(blue "arithmetic")^(green ")")^" | "^
	    (green "(-")^(blue "arithmetic")^(green ")")^" |"^
	    " "^(green "abs(")^(blue "arithmetic")^(green ")")^" |\n"^
	    "  "^(blue "arithmetic")^(green "+")^(blue "arithmetic")^" |"^
	    " "^(blue "arithmetic")^(green "-")^(blue "arithmetic")^" |"^
	    " "^(blue "arithmetic")^(green "*")^(blue "arithmetic")^" |"^
	    " "^(blue "arithmetic")^(green "/")^(blue "arithmetic")^" |\n"
	)^"\n"
	;

	(
	  (cyan ~bold:true "boolean")^" :=\n"^
	    "  "^(green "true")^" | "^(green "false")^" | "^(green "?")^" | "^(blue "identifier")^" | "^(green "(")^(blue "boolean")^(green ")")^" |"^
	    " "^(green "not(")^(blue "boolean")^(green ")")^" |\n"^

	    "  "^(blue "boolean")^(green "&")^(blue "boolean")^" |"^
	    " "^(blue "boolean")^(green "|")^(blue "boolean")^" |"^
	    "  "^(blue "arithmetic")^(green " in ")^(kwa ["[";"]"])^(blue " arithmetic ")^(green ",")^(blue " arithmetic ")^(kwa ["[";"]"])^" |\n"^
	    " "^(blue "arithmetic")^(green "=")^(blue "arithmetic")^" | "^(blue "boolean")^(green "=")^(blue "boolean")^" |"^
	    " "^(blue "arithmetic")^(green "<>")^(blue "arithmetic")^" | "^(blue "boolean")^(green "<>")^(blue "boolean")^" |"^
	    " "^(blue "arithmetic")^(green "<=")^(blue "arithmetic")^" | "^(blue "boolean")^(green "<=")^(blue "boolean")^" |\n"
	)^"\n"
	;
	(
	  (cyan ~bold:true "instruction")^" :=\n"^
	    "  "^(green "P(")^(blue "identifier")^(green ")")^" | "^(green "take(")^(blue "identifier")^(green ")")^" | "^(green "pakken(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "V(")^(blue "identifier")^(green ")")^" | "^(green "release(")^(blue "identifier")^(green ")")^" | "^(green "vrijlaten(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "C(")^(blue "identifier")^(green ")")^" | "^(green "call(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "F(")^(blue "identifier")^(green ")")^" | "^(green "fork(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "W(")^(blue "identifier")^(green ")")^" | "^(green "wait(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "N(")^(blue "identifier")^(green ")")^" | "^(green "notify(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "A(")^(blue "identifier")^(green ")")^" | "^(green "notify_all(")^(blue "identifier")^(green ")")^" |\n"^
	    "  "^(green "S(")^(blue "identifier")^"["^(green ",")^(blue "message")^"]"^(green ")")^" | "^(green "send(")^(blue "identifier")^"["^(green ",")^(blue "message")^"]"^(green ")")^" |\n"^
	    "  "^(green "R(")^(blue "identifier")^"["^(green ",")^(blue "identifier")^"]"^(green ")")^" | "^
	    (green "receive(")^(blue "identifier")^"["^(green ",")^(blue "identifier")^"]"^(green ")")^" |\n"^
	    "  "^(green "M(")^(blue "identifier")^"["^(green ",")^(blue "identifier")^"]"^(green ")")^" | "^(green "monitor(")^(blue "identifier")^"["^(green ",")^(blue "identifier")^"]"^(green ")")^" |\n"^
	    "  "^(green "@(")^(blue "identifier")^(green ",")^"("^(blue "arithmetic")^"|"^(blue "boolean")^")"^(green ")")^" |"^
	    " "^(green "(")^(blue "matching_cases")^(green ")\n")
	)^"\n"
	;

	(
	  (cyan ~bold:true "matching_cases")^" :=\n"^
	    "  "^(blue "process")^(green "+")^"["^(green "[")^(blue "boolean")^(green "]+")^"]"^(blue "process")^" |\n"^
	    "  "^(blue "process")^(green "+")^"["^(green "[")^(blue "boolean")^(green "]+")^"]"^(blue "matching_cases\n")
	)^"\n"
	;

	(
	  (cyan ~bold:true "process")^" :=\n  "^
	    (green "#void")^" | "^
	    (green "()")^" | "^
	    (blue "instruction")^" | "^
	    (green "(")^(blue "process")^(green ")")^" | "^
	    (blue "instruction ")^(kwa [".";":"])^(blue " process")^"\n"
	)^"\n"
	;
	(
	  (cyan ~bold:true "equation")^" :=\n  "^(blue "identifier")^(green " = ")^(blue "process\n")
	)^"\n"
	;
	(rcl ~s:";" "equation" "list_of_equations")^"\n"
	;
	((cyan ~bold:true "program")^" :=\n  ["^(blue "list_of_declarations")^"]["^(kwa ["procs:";"proc:"])^(blue "list_of_equations")^"]["^(kwa ["init:";"Init:";"INIT:";"usrRoot:"])^(blue " init_list")^"]"^(green " END"))^"\n"
      ]


let pv2 () =
  let line = (String.make !Settings.terminal_width '_')^"\n" in
  let nl = "\n" in
  String.concat ""
[
line;nl;
header " Lexical conventions " "";nl;
Printf.sprintf "%s := ['%s'-'%s']" (bc "digit") (bm "0") (bm "9") ; nl; 
Printf.sprintf "%s := ['%s'-'%s']" (bc "lowercase") (bm "a") (bm "z") ; nl; 
Printf.sprintf "%s := ['%s'-'%s']" (bc "uppercase") (bm "A") (bm "Z") ; nl;
Printf.sprintf "%s := ['%s' '%s']" (bc "special") (bm "$") (bm "_") ; nl;
Printf.sprintf "%s := %s+" (bc "number") (blue "digit") ; nl;
Printf.sprintf "%s := %s|%s" (bc "alpha") (blue "lowercase") (blue "uppercase") ; nl ;
Printf.sprintf "%s := %s+(%s|%s|%s)*" (bc "name") (blue "lowercase") (blue "digit") (blue "alpha") (blue "special") ;
nl;line;nl;
header " Grammar " "";nl;
Printf.sprintf "%s := %s|%s %s" (bc "listofnames") (blue "name") (blue "name") (blue "listofnames");nl;nl;
Printf.sprintf "%s :=\n  (%s|%s) [%s] %s |" (bc "header") (green "#semaphore") (green "#sem") (blue "number") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) [%s] %s |" (green "#semaphore_quantitative") (green "#semq") (blue "number") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) %s | " (green "#mutex") (green "#mtx") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) %s | " (green "#mutex_recursive") (green "#mtxr") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) %s | " (green "#mutex_normal") (green "#mtxn") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) %s | " (green "#mutex_errorcheck") (green "#mtxec") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s|%s) [%s] %s | " (green "#file") (green "#fifo") (green "#queue") (blue "number") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s|%s) [%s] %s | " (green "#pile") (green "#lifo") (green "#stack") (blue "number") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) [%s] %s | " (green "#synchronization") (green "#syn") (blue "number") (blue "listofnames");nl;
Printf.sprintf "  (%s|%s) %s | " (green "#monitor") (green "#mntr") (blue "listofnames");
nl;nl;
Printf.sprintf "%s := %s %s %s | %s %s %s [%s] %s"
(bc "equations")
(blue "name") (green "=") (blue "process") 
(blue "name") (green "=") (blue "process") (green ";") (blue "equations")
;
nl;nl;
Printf.sprintf "%s := %s|%s|%s (%s|%s) %s"
(bc "processus")
(green "#void")
(blue "instruction")
(blue "instruction") (green ".") (green ":") (blue "processus");
nl;nl;
Printf.sprintf "%s :=\n  %s|%s|%s|%s|%s|%s|%s|\n  %s|%s|%s|%s|%s "
(bc "instruction")
(Printf.sprintf "%s%s%s" (green "P(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "V(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "C(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "F(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "W(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "N(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s" (green "A(") (blue "name") (green ")"))
(Printf.sprintf "%s%s%s%s%s" (green "S(") (blue "name") (green ",{")  (blue "message") (green "})"))
(Printf.sprintf "%s%s%s%s%s" (green "R(") (blue "name") (green ",")  (blue "name") (green ")"))
(Printf.sprintf "%s%s%s%s%s" (green "M(") (blue "name") (green ",")  (blue "name") (green ")"))
(Printf.sprintf "%s%s%s%s%s" (green "@(") (blue "name") (green ",")  (blue "name") (green ")"))
  (blue "branching")
;nl;nl;
Printf.sprintf "%s := %s | %s | %s"
(bc "branching")
(blue "processus")
(Printf.sprintf "%s%s%s%s%s" (blue "processus") (green "+[") (blue "boolean") (green "]+") (blue "branching"))
(Printf.sprintf "%s%s%s" (blue "processus") (green "+") (blue "branching"))
;nl;nl;
Printf.sprintf "%s := %s |\n  %s | %s | %s | %s | %s |\n  %s | %s | %s"
(bc "arithmetic")
(Printf.sprintf "%s%s%s" (green "(") (blue "arithmetic") (green ")"))
(blue "name")
(blue "number")
(Printf.sprintf "%s %s" (green "abs") (blue "arithmetic"))
(Printf.sprintf "%s%s" (green "-") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "+") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "*") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "-") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "/") (blue "arithmetic"))
;nl;nl;
Printf.sprintf "%s := %s | %s | %s | %s | %s | %s | %s |\n  %s | %s | %s | %s |\n  %s | %s | %s | %s |\n  %s | %s | %s"
(bc "boolean")
(Printf.sprintf "%s%s%s" (green "(") (blue "boolean") (green ")"))
(blue "name")
(green "true")
(green "false")
(green "?")
(Printf.sprintf "%s %s" (green "not") (blue "boolean"))
(Printf.sprintf "%s%s" (green "¬") (blue "boolean"))
(Printf.sprintf "%s%s%s" (blue "boolean") (green "&") (blue "boolean"))
(Printf.sprintf "%s%s%s" (blue "boolean") (green "|") (blue "boolean"))
(Printf.sprintf "%s %s %s" (blue "boolean") (green "⋀") (blue "boolean"))
(Printf.sprintf "%s %s %s" (blue "boolean") (green "⋁") (blue "boolean"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "<=") (blue "arithmetic"))
(Printf.sprintf "%s %s %s" (blue "arithmetic") (green "⩽") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green ">=") (blue "arithmetic"))
(Printf.sprintf "%s %s %s" (blue "arithmetic") (green "⩾") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "<>") (blue "arithmetic"))
(Printf.sprintf "%s %s %s" (blue "arithmetic") (green "≠") (blue "arithmetic"))
(Printf.sprintf "%s%s%s" (blue "arithmetic") (green "==") (blue "arithmetic"))
;nl;nl;
Printf.sprintf "%s := %s |\n  %s"
(bc "lincombofnames")
(Printf.sprintf "[%s[%s]] %s" (blue "number") (green "*") (blue "name"))
(Printf.sprintf "[%s[%s]] %s [%s] %s" (blue "number") (green "*") (blue "name") (green "|") (blue "lincombofnames"))
;nl;nl;
Printf.sprintf "%s := %s %s %s"
(bc "program")
(blue "header")
(Printf.sprintf "(%s|%s) %s" (green "processes:") (green "procs:") (blue "equations"))
(Printf.sprintf "(%s|%s|%s|%s) %s" (green "INIT:") (green "Init:") (green "init:") (green "usrRoot:") (blue "listofnames"))
;nl
]


end

