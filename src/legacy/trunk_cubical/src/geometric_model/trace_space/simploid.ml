open Common

module Int = struct
  type t = int
  let compare = compare
end

module IM = Map.Make(Int)
module IS = Set.Make(Int)

module Simplicial = struct
  module rec S
    : sig
      type t = {
        dim: int;
        (* TODO: remove mutable *)
        mutable faces: t array;
        id:int;
        (* Simplicial set generated by the simplex. *)
        (* TODO: remove *)
        mutable below:SS.t
      }
      val compare: t -> t -> int
      val construct: int -> t array -> t
      val set_faces: t -> t array -> unit
      val get_faces: t -> t array
      val get_dim: t -> int
      val get_below: t -> SS.t
      val set_below: t -> SS.t -> unit
      end
    = struct
      type t = {dim: int; mutable faces: t array; id:int; mutable below:SS.t}
      let compare = compare
      let max_id = ref 0
      let construct d f = max_id := !max_id + 1; {dim=d; faces=f; id=(!max_id); below=SS.empty}
      let set_faces s f = s.faces <- f
      let get_faces s = s.faces
      let get_dim s = s.dim
      let get_below s = s.below
      let set_below s below = s.below <- below
      let map_faces f s = construct s.dim (Array.map f s.faces)
  end
  and SS
    : Set.S with type elt = S.t
    = Set.Make(S)

  module SM = Map.Make(S)

  type t = SS.t array


  let standard dim =
    let simplicial_array = Array.init (dim + 2) (fun x -> SS.empty) in
    (* let nth_bit n i = (n lsr i) land 1 in (*unused variable*) *)
    let rec count_bits n =
      if n = 0 then
        0
      else
        (n land 1) + count_bits (n lsr 1)
    in
    let simplices =
      Array.init
        (1 lsl (dim + 1))
        (fun j ->
          S.construct
            ((count_bits j) - 1)
            [||]
        )
    in
    for j = (1 lsl (dim + 1) - 1) downto 0 do
      simplicial_array.(count_bits j) <- SS.add simplices.(j) simplicial_array.(count_bits j);
      let k = ref [] in
      for i = 0 to dim do
	if (j lsr i) land 1 = 1 then
	  k := simplices.(j-(1 lsl i))::!k
      done;
      S.set_faces simplices.(j)  (Array.of_list !k);
    done;
    for j = 0 to (1 lsl (dim + 1) - 1) do
      let k = ref [] in
      for i = 0 to dim do
	if (j lsr i) land 1 = 1 then
	  k := (S.get_below simplices.(j-(1 lsl i)))::!k
      done;
      let below = List.fold_left (fun acc ss -> SS.union acc ss ) SS.empty !k in
      S.set_below simplices.(j)  (SS.add simplices.(j) below);
    done;
    (simplices.(1 lsl (dim + 1) - 1), simplicial_array)

  let d idx simplex = (S.get_faces simplex).(idx)

  let choose s_set dim =
    SS.choose s_set.(dim + 1)

  let union s1 s2 =
    let dim = (max (Array.length s1) (Array.length s2)) - 2 in
    let simplicial_array = Array.init (dim + 2) (fun x -> SS.empty) in
      for j = 0 to (dim + 1) do
	let sj1 = if (j < (Array.length s1)) then s1.(j) else SS.empty in
	let sj2 = if (j < (Array.length s2)) then s2.(j) else SS.empty in
	  simplicial_array.(j) <- (SS.union sj1 sj2)
      done;
      simplicial_array


  let rec identify super s1 s2 =
    let make_idmap sarray =
      let idmap = ref SM.empty in
      Array.iter
	(fun sset ->
	  idmap := SS.fold
	    (fun b a -> SM.add b b a)
	    sset
	    !idmap)
	sarray;
      !idmap
    in
    let compose_map amap bmap =
      SM.map (fun s -> SM.find s amap) bmap in
    let dim = S.get_dim s1 in
    let qmap = ref (make_idmap super) in
    let result = ref super in
    let _ = Array.iter2
      (fun a b -> if a <> b then
	  let out = identify !result (SM.find a !qmap) (SM.find b !qmap) in
	  qmap := compose_map (snd out) !qmap;
	  result := (fst out))
      (S.get_faces s1)
      (S.get_faces s2) in
    let new_s = S.construct dim (S.get_faces (SM.find s1 !qmap)) in
    let _ = qmap := SM.add s2 new_s (SM.add s1 new_s !qmap) in
    let out_result =
      Array.mapi
        (fun i sset ->
	  let d = i - 1 in
	  SS.map
	    (fun simplex ->
	      if (d < dim) then
	        SM.find simplex !qmap
	      else if d = dim then
	        if simplex = s1 then new_s else if simplex = s2 then new_s else SM.find simplex !qmap
	        else
		  let new_simplex =
                    ref
                      (S.construct d
		         (Array.map
		            (fun f -> SM.find f !qmap)
		            (S.get_faces simplex)))
                  in
		  qmap := SM.add simplex !new_simplex !qmap;
		  !new_simplex
	    )
	    sset)
        super
    in
    (out_result, !qmap)

  let components s =
    let color_redirect = ref IM.empty in
    let color_map = ref SM.empty in
    let highest_color = ref 0 in
    let new_color () =
      highest_color := !highest_color + 1;
      !highest_color in
    let rec redirect color =
      let new_color = if IM.mem color !color_redirect then IM.find color !color_redirect else color in
      if new_color = color then new_color else redirect new_color in
    let rec set_color s c =
      color_map := SM.add s c !color_map;
      Array.iter
	(fun t -> set_color t c)
	(S.get_faces s) in
    let rec get_colors simplex =
      let my_colors = if SM.mem simplex !color_map then IS.singleton (redirect (SM.find simplex !color_map)) else IS.empty in
      IS.union
	my_colors
	(Array.fold_left (fun a b -> IS.union a (get_colors b)) IS.empty (S.get_faces simplex)) in
    for d = (Array.length s - 1) downto 0 do
      SS.iter
	(fun simplex ->
	  let color =
	    let colors = get_colors simplex in
	    if colors = IS.empty then
	      new_color ()
	    else if IS.cardinal colors = 1 then
	      IS.choose colors
	    else
	      let min_color = IS.min_elt colors in
	      IS.iter
		(fun c -> color_redirect := IM.add c (IS.min_elt colors) !color_redirect)
		colors;
	      min_color in
	  set_color simplex color
	)
	s.(d);
    done;
    IS.cardinal
      (
        SM.fold
          (fun _ x is -> IS.add (redirect x) is)
          !color_map
          IS.empty
      )
    (* IS.cardinal (IS.of_enum (Enum.map redirect (SM.values !color_map))) *)
end

(*
module S = Simplicial

let x = S.standard 5
let a = S.standard 5
let b = S.union (snd a) (snd x)
let l = S.SS.elements (S.SS.remove (fst a) b.(3))
let w = S.identify b (S.d 0 (fst a)) (S.d 0 (fst x))
let m = S.components b
let n = S.components (fst w)
let t = S.SS.cardinal (fst w).(0)
*)

module Simploidal = struct
  module rec S
    : sig
      type t = {typ: int array; mutable faces: t array array; id:int; mutable below:SS.t}
      val compare: t -> t -> int
      val get_dim: t -> int
      val construct: int array -> t array array -> t
      val get_type: t -> int array
      val get_faces: t -> t array array
      val set_faces: t -> t array array -> unit
      val get_faces_as_enum: t -> t Enum.t
      val is_empty: t -> bool
      val set_below: t -> SS.t -> unit
      val get_below: t -> SS.t
    end
    = struct
      type t = {typ: int array; mutable faces: t array array; id:int; mutable below:SS.t}
      let max_id = ref 0
      let construct t f = max_id := !max_id + 1; {typ=t; faces=f; id=(!max_id); below=SS.empty}
      let set_faces s f = s.faces <- f
      let get_faces s = s.faces
      let is_empty s = Array.exists (fun x -> x < 0) s.typ
      let get_faces_as_enum s =
        Array.fold_left
	  (fun a farray ->
	    Enum.append
	      a
	      (Array.enum farray))
	  (Enum.empty ())
	  s.faces
      let get_type s = s.typ
      let map_faces f s = construct s.typ (Array.map f s.faces)
      let get_dim s = if (Array.for_all (fun k -> k <> -1) s.typ) then Array.reduce (+) s.typ else -1
      let get_id s = s.id
      let set_below s b = s.below <- b
      let get_below s = s.below
      let compare s1 s2 =
	match compare (get_dim s1) (get_dim s2) with
	    -1 -> -1
	  | 1 -> 1
	  | _ -> compare s1.id s2.id
    end
  and SS
    : Set.S with type elt = S.t
    = Set.Make(S)

  module S' = struct
    type t = S.t * S.t
    let compare = compare
  end

  module SM = Map.Make(S)
  module S'M = Map.Make(S')

  type t = SS.t



  let get_count sset =
    List.map S.get_dim (SS.elements sset)
    (*List.of_enum (Enum.map S.get_dim (SS.enum sset)) *)


  let refresh_below sset =
    SS.iter
      (fun simploid ->
	 let below = SS.add simploid (Enum.fold (fun acc s -> SS.union acc (S.get_below s)) SS.empty (S.get_faces_as_enum simploid)) in
	   S.set_below simploid below
      )
      sset

  let product sset1 sset2 =
    let fst' = fun (a,b,c) -> a in
    let snd' = fun (a,b,c) -> b in
    let trd' = fun (a,b,c) -> c in
    let (new_sset, new_to_old, old_to_new) =
      SS.fold
        (fun s1 acc ->
	  SS.fold
	    (fun s2 acc' ->
	      let new_s = S.construct
	        (Array.append (S.get_type s1) (S.get_type s2))
	        [||]
	      in
	      (SS.add
	         new_s
	         (fst' acc'),
	       SM.add
	         new_s
	         (s1, s2)
	         (snd' acc'),
	       S'M.add
	         (s1, s2)
	         new_s
	         (trd' acc'))
	    )
	    sset2
	    acc)
        sset1
        (SS.empty, SM.empty, S'M.empty) in

    (*Look up new face maps *)
    SS.iter
      (fun new_s ->
	let (old1, old2) = (SM.find new_s new_to_old) in
	let new_faces1 =
          Array.init
            (Array.length (S.get_type old1))
            (fun i ->
              Array.init
                (S.get_type old1).(i)
                (fun j -> S'M.find ((S.get_faces old1).(i).(j),old2) old_to_new)
            )
            (*
            Array.of_enum (
	      Enum.map
	        (fun i ->
	          Array.of_enum
		    (Enum.map
		       (fun j -> S'M.find ((S.get_faces old1).(i).(j),old2) old_to_new)
		       (0--(S.get_type old1).(i) ))
	        )
	        (0--((Array.length (S.get_type old1)) - 1)))
            *)
        in
	let new_faces2 =
          Array.init
            (Array.length (S.get_type old2))
            (fun i ->
              Array.init
                (S.get_type old2).(i)
                (fun j -> S'M.find (old1, (S.get_faces old2).(i).(j)) old_to_new)
            )
          (*
          Array.of_enum (
	    Enum.map
	      (fun i ->
	        Array.of_enum
		  (Enum.map
		     (fun j -> S'M.find (old1, (S.get_faces old2).(i).(j)) old_to_new)
		     (0--(S.get_type old2).(i)))
	      )
	      (0--((Array.length (S.get_type old2)) - 1)))
          *)
        in
	S.set_faces new_s (Array.append new_faces1 new_faces2)
      )
      new_sset
    ;
    (*Look up new "below"*)
    (*refresh_below new_sset;*)
    new_sset

  let d i j s = (S.get_faces s).(i).(j)

  let maximal sset =
    SS.fold
      (fun simploid a ->
        SS.add simploid
	  (Array.fold_right
	     (fun ar a' ->
	       Array.fold_right
	         (fun f a'' -> SS.remove f a'')
	         ar
	         a')
	     (S.get_faces simploid)
	     a))
      sset
      SS.empty

  let of_simplicial s =
    let smap = ref Simplicial.SM.empty in
    Array.iter
      (fun sset -> Simplicial.SS.iter
	(fun simplex ->
	  smap := Simplicial.SM.add simplex
	    (S.construct [|Simplicial.S.get_dim simplex|] [||])
	    !smap)
	sset)
      s;
    Array.iter
      (fun sset -> Simplicial.SS.iter
	(fun simplex ->
	  S.set_faces
	    (Simplicial.SM.find simplex !smap)
	    [|Array.map (fun f -> (Simplicial.SM.find f !smap)) (Simplicial.S.get_faces simplex)|])
	sset)
      s;
    Array.iter
      (fun sset -> Simplicial.SS.iter
	(fun simplex ->
	  S.set_below
	    (Simplicial.SM.find simplex !smap)
	    (SS.of_enum (Enum.map
			   (fun sub -> (Simplicial.SM.find sub !smap))
			   (Simplicial.SS.enum (Simplicial.S.get_below simplex))))
	)
	sset)
      s;
    Array.fold_left
      SS.union
      SS.empty
      (Array.map
	 (fun sset ->
	   SS.of_enum (
	     Enum.map
	       (fun simplex ->
		 Simplicial.SM.find simplex !smap)
	       (Simplicial.SS.enum sset)))
	 s)



  let union s1 s2 =
    SS.union s1 s2

  let euler s =
    let rec pow a b = if b = 0 then 1 else a * (pow a (b - 1)) in
    SS.fold
      (fun simplex a ->
	let dim = S.get_dim simplex in
	if dim >= 0 then
	  a + (pow (-1) (dim mod 2))
	else a)
      s 0

  let copy sset simplices =
    let old_to_new = ref SM.empty in
    let new_sset = SS.map
      (fun s ->
	let new_s = S.construct (S.get_type s)
	  (Array.map (fun t ->
	    Array.map
	      (fun face -> SM.find face !old_to_new)
	      t)
	     (S.get_faces s)) in
	old_to_new := SM.add s new_s !old_to_new;
	new_s)
      sset in

    (new_sset, Array.map
      (fun old -> SM.find old !old_to_new)
      simplices)


  let components sset =
    let color_redirect = ref IM.empty in
    let color_map = ref SM.empty in
    let highest_color = ref 0 in

    let new_color () =
      highest_color := !highest_color + 1;
      !highest_color in

    let rec redirect color =
      let new_color = if IM.mem color !color_redirect then IM.find color !color_redirect else color in
      if new_color = color then new_color else redirect new_color in

    let rec set_color simplex c =
      if (not (S.is_empty simplex)) then (
	color_map := SM.add simplex c !color_map;
	Array.iter
	  (fun t -> Array.iter
	    (fun s -> set_color s c)
	    t)
	  (S.get_faces simplex)) in

    let rec get_colors simplex =
      let my_color = if SM.mem simplex !color_map then IS.singleton (redirect (SM.find simplex !color_map)) else IS.empty in
      IS.union
	my_color
	(Array.fold_left (fun is ar -> IS.union is (Array.fold_left (fun a b -> IS.union a (if (not (S.is_empty b)) then get_colors b else IS.empty)) IS.empty ar)) IS.empty (S.get_faces simplex)) in


    SS.iter
      (fun simplex ->
	let color =
	  let colors = get_colors simplex in
	  if colors = IS.empty then
	    new_color ()
	  else if IS.cardinal colors = 1 then
	    IS.choose colors
	  else
	    let min_color = IS.min_elt (IS.map redirect colors) in
	    IS.iter
	      (fun c -> color_redirect := IM.add c (IS.min_elt colors) !color_redirect)
	      colors;
	    min_color in
	set_color simplex color)
      (SS.filter (fun s -> not (S.is_empty s)) sset);
    IS.cardinal (SM.fold (fun _ x is -> IS.add (redirect x) is) !color_map IS.empty)
  (* IS.cardinal (IS.of_enum (Enum.map redirect (SM.values !color_map))) *)

  let type_leq t1 t2 =
    if Array.length t1 <> Array.length t2 then false
    else List.for_all2 (fun a b -> a <= b) (Array.to_list t1) (Array.to_list t2)
    

  let compose_map amap bmap = 
    SM.map (fun s -> if SM.mem s amap then SM.find s amap else s) bmap


  let rec identify super a b olookup =
    let make_idmap sset =
      SS.fold
	(fun b a -> SM.add b b a)
	sset
	SM.empty in
    let lookup = match olookup with
	None -> make_idmap super
      | Some x -> x in
    let s1 = if SM.mem a lookup then SM.find a lookup else a in
    let s2 = if SM.mem b lookup then SM.find b lookup else b in 
    (*let temp = ref SS.empty in(*unused variable*)*)
    let compose_map amap bmap = 
      SM.map (fun s -> if SM.mem s amap then SM.find s amap else s) bmap in

    let typ = S.get_type s1 in
    let qmap = ref (make_idmap super) in
    let result = ref super in
    let _ = Array.iter2 
      (fun a2 b2 -> Array.iter2
	 (fun a b -> if a <> b then
	    let out = identify !result (SM.find a !qmap) (SM.find b !qmap) (Some lookup) in
	      qmap := compose_map (snd out) !qmap;
	      result := (fst out)) 
	 a2 b2)
      (S.get_faces s1)
      (S.get_faces s2) in
    let new_s = S.construct typ (S.get_faces (SM.find s1 !qmap)) in
    let _ = qmap := SM.add s2 new_s (SM.add s1 new_s !qmap) in
    let out_result = SS.map 
      (fun simplex -> 
	 let current_type = S.get_type simplex in
	   if ((type_leq current_type typ) && (current_type <> typ)) then
	     SM.find simplex !qmap
	   else if current_type = typ then
	     if simplex = s1 then new_s else if simplex = s2 then new_s else SM.find simplex !qmap
	   else
	     let new_simplex = ref (S.construct current_type 
				      (Array.map
					 (fun array -> Array.map
					    (fun f -> SM.find f !qmap)
					    array)
					 (S.get_faces simplex))) in
	       qmap := SM.add simplex !new_simplex !qmap;
	       !new_simplex) 
      super in
      (out_result,  !qmap)

end



(*let tetra = Simploidal.of_simplicial (snd (Simplicial.standard 3)) 
let b = Simploidal.product tetra tetra
let c = Simploidal.product tetra b
let d = Simploidal.product tetra c*)
(*

This is an example of the creation of a torus.

let line = Simploidal.of_simplicial (snd (Simplicial.standard 1))
let square1 = Simploidal.product line line
let line100 = (Simploidal.S.get_faces (Simploidal.SS.choose (Simploidal.maximal square1))).(0).(0)
let line101 = (Simploidal.S.get_faces (Simploidal.SS.choose (Simploidal.maximal square1))).(0).(1)
let line110 = (Simploidal.S.get_faces (Simploidal.SS.choose (Simploidal.maximal square1))).(1).(0)
let line111 = (Simploidal.S.get_faces (Simploidal.SS.choose (Simploidal.maximal square1))).(1).(1)
let (square2,[|line200;line201;line210;line211|]) = Simploidal.copy square1 [|line100;line101;line110;line111|]
let (square3,[|line300;line301;line310;line311|]) = Simploidal.copy square1 [|line100;line101;line110;line111|]
let squares = Simploidal.union (Simploidal.union square1 square2) square3
let (cylinder, m) = Simploidal.identify squares line101 line200 None
let (cylinder, n) = Simploidal.identify cylinder line201 line300 (Some m)
let m = Simploidal.compose_map n m
let (cylinder1, n) = Simploidal.identify cylinder line301 line100 (Some m)
let m = Simploidal.compose_map n m

let cline101 = Simploidal.SM.find line110 m
let cline102 = Simploidal.SM.find line210 m
let cline103 = Simploidal.SM.find line310 m
let cline111 = Simploidal.SM.find line111 m
let cline112 = Simploidal.SM.find line211 m
let cline113 = Simploidal.SM.find line311 m

let (cylinder2,[|cline201;cline202;cline203;cline211;cline212;cline213|]) = Simploidal.copy cylinder1 [|cline101;cline102;cline103;cline111;cline112;cline113|]
let (cylinder3,[|cline301;cline302;cline303;cline311;cline312;cline313|]) = Simploidal.copy cylinder1 [|cline101;cline102;cline103;cline111;cline112;cline113|]
let cylinders = Simploidal.union (Simploidal.union cylinder1 cylinder2) cylinder3

let (torus, m) = Simploidal.identify cylinders cline111 cline201 None
let (torus, n) = Simploidal.identify torus cline112 cline202 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline113 cline203 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline211 cline301 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline212 cline302 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline213 cline303 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline311 cline101 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline312 cline102 (Some m)
let m = Simploidal.compose_map n m
let (torus, n) = Simploidal.identify torus cline313 cline103 (Some m)
let m = Simploidal.compose_map n m

let e = Simploidal.euler torus
let c = Simploidal.components torus
*)


